<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: loaders, | David Calhoun's blog]]></title>
  <link href="http://davidbcalhoun.com/blog/categories/loaders/atom.xml" rel="self"/>
  <link href="http://davidbcalhoun.com/"/>
  <updated>2014-04-30T12:17:16-07:00</updated>
  <id>http://davidbcalhoun.com/</id>
  <author>
    <name><![CDATA[David Calhoun]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[What is AMD, CommonJS, and UMD?]]></title>
    <link href="http://davidbcalhoun.com/2014/what-is-amd-commonjs-umd/"/>
    <updated>2014-04-30T11:59:21-07:00</updated>
    <id>http://davidbcalhoun.com/2014/what-is-amd-commonjs-umd</id>
    <content type="html"><![CDATA[<h3 id="intro">Intro</h3>
<p>Over the years there’s been a steadily increasing ecosystem of JavaScript components to choose from.  The sheer amount of choices is fantastic, but this also infamously presents a difficulty when components are mixed-and-matched.  And it doesn’t take too long for budding developers to find out that not all components are built to play nicely together.</p>

<p>To address these issues, the competing module specs AMD and CommonJS have appeared on the scene, allowing developers to write their code in an agreed-upon sandboxed and modularized way, so as not to “pollute the ecosystem”.</p>

<h3 id="amd">AMD</h3>
<p>Asynchronous Module Definition (AMD) has gained traction on the frontend, with RequireJS being the most popular implementation.</p>

<p>Here’s module <code>foo</code> with a single dependency on <code>jquery</code>:</p>

<pre><code>//    filename: foo.js
define(['jquery'], function ($) {
    //    methods
    function myFunc(){};

    //    exposed public methods
    return myFunc;
});
</code></pre>

<p>And a little more complicated example with multiple dependencies and multiple exposed methods:</p>

<pre><code>//    filename: foo.js
define(['jquery', 'underscore'], function ($, _) {
    //    methods
    function a(){};    //    private because it's not returned (see below)
    function b(){};    //    public because it's returned
    function c(){};    //    public because it's returned

    //    exposed public methods
    return {
        b: b,
        c: c
    }
});
</code></pre>

<p>The first part of the define is an array of dependencies, while the second part is essentially the callback function which is only executed when the dependencies are available (script loaders like RequireJS take care of that part, including figuring out where the files are located).</p>

<p>Note that the dependency to variable order is important (ex. jquery-&gt;<code>$</code>, underscore-&gt;<code>_</code>).</p>

<p>Also note that we can map the dependencies to any arbitrary variables we want here.  If we change <code>$</code> to <code>$$</code> in the code above, all jQuery references within our function block will be <code>$$</code> instead of <code>$</code>.</p>

<p>And note, most importantly, that you can’t reference the variables <code>$</code> and <code>_</code> outside of the function, because it’s sandboxed from other code.  That’s the goal here!</p>

<h3 id="commonjs">CommonJS</h3>

<p>CommonJS is a style you may be familiar with if you’re written anything in Node (which uses a slight variant).  It’s also been gaining traction on the frontend with Browserify.</p>

<p>Using the same format as before, here’s what our <code>foo</code> module looks like in CommonJS:</p>

<pre><code>//    filename: foo.js

//    dependencies
var $ = require('jquery');

//    methods
function myFunc(){};

//    exposed public method (single)
module.exports = myFunc;
</code></pre>

<p>And our more complicate example, with multiple dependencies and multiple exposed methods:</p>

<pre><code>//    filename: foo.js
var $ = require('jquery');
var _ = require('underscore');

//    methods
function a(){};    //    private because it's omitted from module.exports (see below)
function b(){};    //    public because it's defined in module.exports
function c(){};    //    public because it's defined in module.exports

//    exposed public methods
module.exports = {
    b: b,
    c: c
};
</code></pre>

<h3 id="umd-universal-module-definition">UMD: Universal Module Definition</h3>

<p>Since CommonJS and AMD styles have both been equally popular, it seems there’s yet no consensus.  This has brought about the push for a “universal” pattern that supports both styles, which brings us to none other than the Universal Module Definition.</p>

<p>The pattern is admittedly ugly, but is both AMD and CommonJS compatible, as well as supporting the old-style “global” variable definition:</p>

<pre><code>(function (root, factory) {
    if (typeof define === 'function' &amp;&amp; define.amd) {
        // AMD
        define(['jquery'], factory);
    } else if (typeof exports === 'object') {
        // Node, CommonJS-like
        module.exports = factory(require('jquery'));
    } else {
        // Browser globals (root is window)
        root.returnExports = factory(root.jQuery);
    }
}(this, function ($) {
    //    methods
    function myFunc(){};

    //    exposed public method
    return myFunc;
}));
</code></pre>

<p>And keeping in the same pattern as the above examples, the more complicated case with multiple dependencies and multiple exposed methods:</p>

<pre><code>(function (root, factory) {
    if (typeof define === 'function' &amp;&amp; define.amd) {
        // AMD
        define(['jquery', 'underscore'], factory);
    } else if (typeof exports === 'object') {
        // Node, CommonJS-like
        module.exports = factory(require('jquery', 'underscore'));
    } else {
        // Browser globals (root is window)
        root.returnExports = factory(root.jQuery, root._);
    }
}(this, function ($, _) {
    //    methods
    function a(){};    //    private because it's not returned (see below)
    function b(){};    //    public because it's returned
    function c(){};    //    public because it's returned

    //    exposed public methods
    return {
        b: b,
        c: c
    }
}));
</code></pre>
]]></content>
  </entry>
  
</feed>
